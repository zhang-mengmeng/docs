import{_ as i,c as e,a2 as s,o as t}from"./chunks/framework.DD8U72qy.js";const g=JSON.parse('{"title":"HTTP 缓存概述：强缓存与协商缓存","description":"","frontmatter":{"outline":"deep","prev":{"text":"http响应头和请求头","link":"/http.md"},"next":{"text":"SEO(搜索引擎优化)","link":"/seo.md"}},"headers":[],"relativePath":"cache.md","filePath":"cache.md","lastUpdated":null}'),o={name:"cache.md"};function l(n,a,d,h,r,c){return t(),e("div",null,a[0]||(a[0]=[s(`<h1 id="http-缓存概述-强缓存与协商缓存" tabindex="-1">HTTP 缓存概述：强缓存与协商缓存 <a class="header-anchor" href="#http-缓存概述-强缓存与协商缓存" aria-label="Permalink to &quot;HTTP 缓存概述：强缓存与协商缓存&quot;">​</a></h1><p>HTTP 缓存（HTTP Caching）是一种提高网页加载速度、减少服务器负载和提高用户体验的技术。它通过在客户端或代理服务器上存储 HTTP 响应，以便在后续请求中直接使用缓存数据，而无需再次从原始服务器获取内容。</p><h2 id="_1-http-缓存的主要类型" tabindex="-1">1. HTTP 缓存的主要类型 <a class="header-anchor" href="#_1-http-缓存的主要类型" aria-label="Permalink to &quot;1. HTTP 缓存的主要类型&quot;">​</a></h2><ul><li><strong><code>浏览器缓存（客户端缓存）</code></strong> : 浏览器在本地存储网页资源，如图片、HTML、CSS、JavaScript 等，以减少重复请求和提高加载速度。</li><li><strong><code>代理缓存</code></strong> : 代理服务器会缓存多个用户的请求和响应，用于减少对原始服务器的访问频率，常见于企业和 ISP 使用的中间缓存。</li><li><strong><code>网关缓存</code></strong> : 应用于反向代理服务器和 CDN（内容分发网络），帮助提高网站的可扩展性和性能。</li></ul><h2 id="_2-常见的缓存控制机制" tabindex="-1">2. 常见的缓存控制机制 <a class="header-anchor" href="#_2-常见的缓存控制机制" aria-label="Permalink to &quot;2. 常见的缓存控制机制&quot;">​</a></h2><ul><li><p><strong>HTTP头字段</strong></p><ul><li><code>Cache-Control</code>：用于定义缓存策略，如 <code>public</code>, <code>private</code>, <code>no-store</code>, <code>no-cache</code>, <code>max-age</code> 等。</li><li><code>Expires</code>：指定缓存过期的具体时间点，常被 <code>Cache-Control: max-age</code> 替代。。</li><li><code>ETag</code>：一种资源的标识符，用于比较资源是否被修改。</li><li><code>Last-Modified</code>：指示资源的最后修改时间，配合 <code>If-Modified-Since</code> 请求头用于条件请求。</li></ul></li><li><p><strong>缓存策略</strong></p><ul><li><code>强缓存</code>：在有效期内直接从缓存中读取，不与服务器通信。使用 <code>Cache-Control: max-age</code> 或 <code>Expires</code> 实现。</li><li><code>协商缓存</code>：缓存过期后，通过 <code>ETag</code> 或 <code>Last-Modified</code> 检查资源是否更新。如果没有更新，返回状态码 <code>304 Not Modified</code> 并继续使用缓存内容。</li></ul></li></ul><h2 id="_3-http-缓存工作流程" tabindex="-1">3. HTTP 缓存工作流程 <a class="header-anchor" href="#_3-http-缓存工作流程" aria-label="Permalink to &quot;3. HTTP 缓存工作流程&quot;">​</a></h2><ul><li><strong>首次请求</strong> : 浏览器或代理向服务器发出请求并获取资源，同时缓存资源及其相关头信息。</li><li><strong>后续请求</strong> : <ul><li>若缓存有效且未过期，使用缓存内容，避免与服务器通信（强缓存）。</li><li>若缓存已过期，发出请求验证资源是否有更新（协商缓存）。如果未更新，返回 304 状态码，并使用缓存内容。</li></ul></li></ul><h2 id="_4-优化缓存策略的好处" tabindex="-1">4. 优化缓存策略的好处 <a class="header-anchor" href="#_4-优化缓存策略的好处" aria-label="Permalink to &quot;4. 优化缓存策略的好处&quot;">​</a></h2><ul><li><strong>减少服务器负载</strong> : 通过缓存减少了请求次数。</li><li><strong>加快页面加载</strong> : 用户访问已缓存的资源时，加载速度显著提高。</li><li><strong>节省带宽</strong> : 减少服务器与客户端之间的数据传输量。</li></ul><h2 id="_5-强缓存-fresh-cache" tabindex="-1">5. 强缓存（Fresh Cache） <a class="header-anchor" href="#_5-强缓存-fresh-cache" aria-label="Permalink to &quot;5. 强缓存（Fresh Cache）&quot;">​</a></h2><p><strong>强缓存</strong>指在缓存有效期内，客户端直接使用缓存数据，不会与服务器通信。</p><h3 id="实现方式" tabindex="-1">实现方式 <a class="header-anchor" href="#实现方式" aria-label="Permalink to &quot;实现方式&quot;">​</a></h3><ul><li><strong><code>Cache-Control: max-age=seconds</code></strong></li><li><strong><code>Expires</code></strong></li></ul><h3 id="示例代码" tabindex="-1">示例代码 <a class="header-anchor" href="#示例代码" aria-label="Permalink to &quot;示例代码&quot;">​</a></h3><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 响应头示例</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Cache-Control</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> max-age=3600</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Expires</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Wed, 22 Nov 2024 08:00:00 GMT</span></span></code></pre></div><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li><strong>不发起请求</strong>：缓存有效期内直接使用缓存资源。</li><li><strong>状态码</strong>：<code>200 (from cache)</code></li></ul><h2 id="_6-协商缓存-conditional-request" tabindex="-1">6. 协商缓存（Conditional Request） <a class="header-anchor" href="#_6-协商缓存-conditional-request" aria-label="Permalink to &quot;6. 协商缓存（Conditional Request）&quot;">​</a></h2><p><strong>协商缓存</strong>指缓存过期后，客户端向服务器验证资源是否更新，若未更新，返回 <code>304 Not Modified</code> 状态码。</p><h3 id="实现方式-1" tabindex="-1">实现方式 <a class="header-anchor" href="#实现方式-1" aria-label="Permalink to &quot;实现方式&quot;">​</a></h3><ul><li><strong><code>ETag</code></strong> 与 <code>If-None-Match</code></li><li><strong><code>Last-Modified</code></strong> 与 <code>If-Modified-Since</code></li></ul><h3 id="示例代码-1" tabindex="-1">示例代码 <a class="header-anchor" href="#示例代码-1" aria-label="Permalink to &quot;示例代码&quot;">​</a></h3><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 响应头示例</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ETag</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Last-Modified</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Wed, 22 Nov 2023 08:00:00 GMT</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 请求头示例</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">If-None-Match</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">If-Modified-Since</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Wed, 22 Nov 2023 08:00:00 GMT</span></span></code></pre></div><h3 id="特点-1" tabindex="-1">特点 <a class="header-anchor" href="#特点-1" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li><strong>发起请求</strong>：缓存过期时与服务器通信验证资源。</li><li><strong>状态码</strong>：<code>304 Not Modified</code> 表示缓存可用，<code>200 OK</code> 表示返回新内容。</li></ul><h2 id="_7-强缓存与协商缓存对比" tabindex="-1">7. 强缓存与协商缓存对比 <a class="header-anchor" href="#_7-强缓存与协商缓存对比" aria-label="Permalink to &quot;7. 强缓存与协商缓存对比&quot;">​</a></h2><ul><li><strong>强缓存</strong>：避免网络请求，提高加载速度。</li><li><strong>协商缓存</strong>：确保获取最新资源。</li></ul><p>通常情况下，浏览器会优先使用强缓存。当强缓存失效时，转为协商缓存进行验证。</p>`,29)]))}const k=i(o,[["render",l]]);export{g as __pageData,k as default};
